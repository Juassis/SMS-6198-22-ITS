---
title: "NBIS Report"
subtitle: '`r format(Sys.Date(),format="%d-%b-%Y")`'

output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    highlight: tango
    df_print: paged
    code_folding: "show"
    self_contained: true
    keep_md: false
    encoding: 'UTF-8'
    #css: "assets/report.css"
  pdf_document: default
---
<!-- ----------------------- Do not edit above this ----------------------- -->

```{r,echo=FALSE,include=FALSE}
# CUSTOM VARIABLES

# custom ggplot theme
theme_report_h <- function (base_size=12,base_family=NULL,colour="grey60") {
  theme_bw(base_size=base_size,base_family=base_family) %+replace%
    theme(
      panel.border=element_blank(),
      panel.grid.minor=element_blank(),
      panel.grid.major.x=element_blank(),
      legend.position="top",
      legend.direction="horizontal",
      legend.justification="center",
      strip.background=element_blank(),
      axis.ticks.y=element_blank(),
      axis.ticks.x=element_line(colour=colour),
      plot.caption=element_text(hjust=0,colour=colour,size=10),
      plot.title=element_text(colour=colour),
      plot.subtitle=element_text(colour=colour)
    )
}

# custom ggplot theme
theme_report <- theme_report_v <- function (base_size=12,base_family=NULL,colour="grey60") {
  theme_bw(base_size=base_size,base_family=base_family) %+replace%
    theme(
      panel.border=element_blank(),
      panel.grid.minor=element_blank(),
      panel.grid.major.x=element_blank(),
      legend.position="right",
      legend.direction="vertical",
      legend.justification="center",
      strip.background=element_blank(),
      axis.ticks.y=element_blank(),
      axis.ticks.x=element_line(colour=colour),
      plot.caption=element_text(hjust=0,colour=colour,size=10),
      plot.title=element_text(colour=colour),
      plot.subtitle=element_text(colour=colour)
    )
}

# custom ggplot theme
theme_simple_h <- function (base_size=12,base_family=NULL,colour="grey60") {
  theme_bw(base_size=base_size,base_family=base_family) %+replace%
    theme(
      panel.border=element_blank(),
      panel.grid=element_blank(),
      legend.justification="center",
      legend.position="top",
      legend.direction="horizontal",
      strip.background=element_blank(),
      axis.ticks=element_blank(),
      axis.text=element_blank(),
      axis.title=element_blank(),
      plot.caption=element_text(hjust=0,colour=colour,size=10),
      plot.title=element_text(colour=colour),
      plot.subtitle=element_text(colour=colour)
    )
}

# custom ggplot theme
theme_simple_v <- function (base_size=12,base_family=NULL,colour="grey60") {
  theme_bw(base_size=base_size,base_family=base_family) %+replace%
    theme(
      panel.border=element_blank(),
      panel.grid=element_blank(),
      legend.justification="center",
      legend.position="right",
      legend.direction="vertical",
      strip.background=element_blank(),
      axis.ticks=element_blank(),
      axis.text=element_blank(),
      axis.title=element_blank(),
      plot.caption=element_text(hjust=0,colour=colour,size=10),
      plot.title=element_text(colour=colour),
      plot.subtitle=element_text(colour=colour)
    )
}

#colours
col_sll_green <- "#95C11E"
col_sll_blue <- "#0093BD"
col_sll_orange <- "#EF7C00"
col_sll_green_light <- "#f4f8e8"
col_sll_blue_light <- "#e5f4f8"
col_sll_orange_light <- "#fdf1e5"

# project variables
rep_nbis_id <- "SMS_6198"
rep_report_version <- "1.0"
rep_request <- "Mona N. Högberg"
rep_request_email <- "mona.n.hogberg@slu.se"
rep_pi <- "Mona N. Högberg"
rep_pi_email <- "mona.n.hogberg@slu.se"
rep_org <- "SLU"
rep_nbis <- "Juliana Assis"
rep_nbis_email <- "juliana.assis@nbis.se"
```

<br>

::: boxy
__NBIS ID:__ `r rep_nbis_id`   
__Report Version:__ `r rep_report_version`  
__Request by:__ `r paste0(rep_request," (",rep_request_email,")")`  
__Principal Investigator:__ `r paste0(rep_pi," (",rep_pi_email,")")`   
__Organisation:__ `r rep_org`  
__NBIS Staff:__ `r paste0(rep_nbis," (",rep_nbis_email,")")`  
:::

<br>

# Setup

```{r message=FALSE, warning=FALSE}
## LIBRARIES
library("dada2")
library("devtools")
library("dplyr")
library("ggplot2")
library("microbiome")
library("phangorn") 
library("phyloseq") 
library("Rcpp")
library("reshape2")
library("tidyr")
library("vegan")
library("ShortRead")
library("Biostrings")
library("DECIPHER")
library("SensusR")
library("gplots")
library("gridExtra")
library("grid")
library("ggpubr")
library("reshape2")
library("reshape")
library("lulu")
library("ggrepel")
library("ggh4x")
library("RColorBrewer")
library("rITSx")
library("MicEco")
library("agricolae")
library("ampvis2")
library("pheatmap")
library("tidyverse")
```

# Version
1.0 

* Support Request
Request sent by the user:\
Mona N. Högberg\

# Data  
96 samples\

* Type of data  

ITS amplicon

* Data location
rackham.uppmax.uu.se
/proj/snic2022-22-352

* Uppmax project ID
SNIC 2022/22-352

* NGI Project ID
P9723

* Database used
Unite

# Tools
NFCore-Ampliseq (Dada2)

```{r,echo=FALSE,include=FALSE}
load("/Users/juliana/Documents/NBIS/Projects/6198/R_Saving/SMS_Phyloseq_VF_ITSx_LULU_3652.RData")
```

```{r}
#Sample Info
head(sample_info_tab)
```

# Workflow

I'm describing here the most important steps in the analysis. Moreover, it is possible to find all parameters and figures at the .rmd file.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Reading Files
path = "/Users/juliana/Documents/NBIS/Projects/6198/Data/Data2" #Data2
#Renaming
#_1.fq.gz
#R2.fastq.gz
fnFs = sort(list.files(path, pattern="_R1.fastq.gz"))
fnRs = sort(list.files(path, pattern="_R2.fastq.gz"))

sample.names = sapply(strsplit(fnFs, "_R"), `[`, 1)
show(sample.names)

fnFs = file.path(path, fnFs)
fnRs = file.path(path, fnRs)
```

```{r, echo=FALSE,include=FALSE, eval = FALSE}
filt_path = file.path(path, "filtered")
filtFs = file.path(filt_path, paste0(sample.names, "_F_filt.fastq"))
filtRs = file.path(filt_path, paste0(sample.names, "_R_filt.fastq"))
#Read Numbers : Rarefaction? Or only after filter. After length 250 (R1), 200 (R2) bad phred score (bellow 20)
#dev.off()
```

### Inspect read quality profiles \

**Quality profiles of the forward reads:** \

```{r,fig.cap="QC Foward Reads.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
#Filter Sequences
a <- plotQualityProfile(fnFs[1:6]) #96
a
ggsave("./PLOTS/Full_Data/QC/1-fnfQC.pdf", a)
```

In gray-scale is a heat map of the frequency of each quality score at each base position. The median quality score at each position is shown by the green line, and the quartiles of the quality score distribution by the orange lines. The red line shows the scaled proportion of reads that extend to at least that position 

The forward reads are good quality
I truncated the forward reads at position 240.

**Quality profile of the reverse reads:** \

```{r,fig.cap="QC Reverse Reads.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE,message=FALSE}

#Filter Sequences
b <- plotQualityProfile(fnRs[1:6]) #96
b
ggsave("./PLOTS/Full_Data/QC/2-fnRQC.pdf", b)
```

The reverse reads are of significantly worse quality, especially at the end, which is common in Illumina sequencing. This isn’t too worrisome, as DADA2 incorporates quality information into its error model which makes the algorithm robust to lower quality sequence, but trimming as the average qualities crash will improve the algorithm’s sensitivity to rare sequence variants. Based on these profiles, I truncated the reverse reads at position 200 where the quality distribution crashes. \

### Identify primers \

The universal primer set 5.8S and ITS1F (Fierer et al., 2005; Yarwood et al., 2010) primers were used to amplify this dataset. We record the DNA sequences, including ambiguous nucleotides, for those primers.

>FWD <- "CTTGGTCATTTAGAGGAAGTAA" \
>REV <- "GCTGCGTTCTTCATCGATGC"

```{r,echo=FALSE, eval = FALSE}
#Defining Primers
FWD <- "CTTGGTCATTTAGAGGAAGTAA"
REV <- "GCTGCGTTCTTCATCGATGC"
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Primer Orientation
allOrients <- function(primer) {
    # Create all orientations of the input sequence
    require(Biostrings)
    dna <- DNAString(primer)  # The Biostrings works w/ DNAString objects rather than character vectors
    orients <- c(Forward = dna, Complement = complement(dna), Reverse = reverse(dna), 
        RevComp = reverseComplement(dna))
    return(sapply(orients, toString))  # Convert back to character vector
}
FWD.orients <- allOrients(FWD)
REV.orients <- allOrients(REV)
FWD.orients
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Pre Filter
fnFs.filtN <- file.path(path, "filtN", basename(fnFs)) # Put N-filterd files in filtN/ subdirectory
fnRs.filtN <- file.path(path, "filtN", basename(fnRs))
filterAndTrim(fnFs, fnFs.filtN, fnRs, fnRs.filtN, maxN = 0, multithread = FALSE)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Checkin Primers
primerHits <- function(primer, fn) {
    # Counts number of reads in which the primer is found
    nhits <- vcountPattern(primer, sread(readFastq(fn)), fixed = FALSE)
    return(sum(nhits > 0))
}
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs.filtN[[1]]), 
    FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs.filtN[[1]]), 
    REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs.filtN[[1]]), 
    REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs.filtN[[1]]))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Removing Primers
cutadapt <- "/opt/homebrew/anaconda3/envs/cutadaptenv/bin/cutadapt" # CHANGE ME to the cutadapt path on your machine
system2(cutadapt, args = "--version") # Run shell commands from R
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Running cutdapt
path.cut <- file.path(path, "cutadapt")
if(!dir.exists(path.cut)) dir.create(path.cut)
fnFs.cut <- file.path(path.cut, basename(fnFs))
fnRs.cut <- file.path(path.cut, basename(fnRs))

FWD.RC <- dada2:::rc(FWD)
REV.RC <- dada2:::rc(REV)
# Trim FWD and the reverse-complement of REV off of R1 (forward reads)
R1.flags <- paste("-g", FWD, "-a", REV.RC) 
# Trim REV and the reverse-complement of FWD off of R2 (reverse reads)
R2.flags <- paste("-G", REV, "-A", FWD.RC) 
# Run Cutadapt
for(i in seq_along(fnFs)) {
  system2(cutadapt, args = c(R1.flags, R2.flags, "-n", 2, # -n 2 required to remove FWD and REV from reads
                             "-o", fnFs.cut[i], "-p", fnRs.cut[i], # output files
                             fnFs.filtN[i], fnRs.filtN[i])) # input files
}
```

**Sanity check of primers and adapters** \
```{r,echo=FALSE}
#sanity check
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs.cut[[1]]), 
    FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs.cut[[1]]), 
    REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs.cut[[1]]), 
    REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs.cut[[1]]))
```
Success! Primers are no longer detected in the cutadapted reads. \

The primer-free sequence files are now ready to be analyzed through the DADA2 pipeline. \

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Data working 
path.cut = "/Users/juliana/Documents/NBIS/Projects/6198/Data/Data2/cutadapt"
# Forward and reverse fastq filenames have the format:
cutFs <- sort(list.files(path.cut, pattern = "_R1.fastq.gz"))
cutRs <- sort(list.files(path.cut, pattern = "_R2.fastq.gz"))
sample.names = sapply(strsplit(cutFs, "_R"), `[`, 1)
show(sample.names)
cutFs = file.path(path.cut, cutFs)
cutRs = file.path(path.cut, cutRs)
```

```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, include=FALSE}
#Inspect read quality profiles
plotQualityProfile(cutFs[1:2])
```

```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, include=FALSE}
plotQualityProfile(cutRs[1:2])
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
##Filter and trim
filtFs <- file.path(path.cut, "filtered", basename(cutFs))
filtRs <- file.path(path.cut, "filtered", basename(cutRs))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
out <- filterAndTrim(cutFs, filtFs, cutRs, filtRs,
                     maxN = 0,maxEE = c(2, 2),
                     #truncLen=c(290,270), 
                     trimLeft = c(10,30),
                     truncQ = 2, minLen = 150,
                     rm.phix = TRUE, compress = TRUE,
                     multithread = TRUE)  # FALSE in M1 mac
head(out)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}

filt_path = "/Users/juliana/Documents/NBIS/Projects/6198/Data/Data2/cutadapt/filtered/"
filtFs = file.path(filt_path, paste0(sample.names, "_R1.fastq.gz"))
filtRs = file.path(filt_path, paste0(sample.names, "_R2.fastq.gz"))
#dev.off()
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
table(file.exists(filtFs)) 
table(file.exists(filtRs))

```

```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, include=FALSE}
plotQualityProfile(filtFs[1:6])
plotQualityProfile(filtFs[1:6])
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
errF <- learnErrors(filtFs, multithread = TRUE)
errR <- learnErrors(filtRs, multithread = TRUE)
```


### Learn the Error Rates

The DADA2 method relies on a parameterized model of substitution errors to distinguish sequencing errors from real biological variation. Because error rates can (and often do) vary substantially between sequencing runs and PCR protocols, the model parameters can be discovered from the data itself using a form of unsupervised learning in which sample inference is alternated with parameter estimation until both are jointly consistent.

In order to verify that the error rates have been reasonably well-estimated, we inspect the fit between the observed error rates (black points) and the fitted error rates (black lines) in the next Figure:

```{r,fig.cap="Error Rate Foward Reads.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
#Plot Error Rate
c <- plotErrors(errF, nominalQ = TRUE)
c
ggsave("./PLOTS/Full_Data/QC/3-errF.pdf", c)

d <- plotErrors(errR, nominalQ = TRUE)
d
ggsave("./PLOTS/Full_Data/QC/4-errR.pdf", d)

```

Everything looks reasonable and we proceed with confidence. \

>After filtering, we moved to the next step:
>
Sequence inference:
The DADA2 sequence inference step removed - nearly - all substitution and indel errors from the data. We now merge together the inferred forward and reverse sequences, removing paired sequences that do not perfectly overlap as a final control against residual errors.

### Construct sequence table and remove chimeras

>The DADA2 method produces a sequence table valued by the number of times each sequence was observed in each sample.

>Notably, chimeras have not yet been removed. The error model in the sequence inference algorithm does not include a chimera component, and therefore we expect this sequence table to include many chimeric sequences. We now remove chimeric sequences by comparing each inferred sequence to the others in the table, and removing those that can be reproduced by stitching together two more abundant sequences.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Dereplicate identical reads

derepFs <- derepFastq(filtFs, 
                      verbose = TRUE)

derepRs <- derepFastq(filtRs, 
                      verbose = TRUE)

# Name the derep-class objects by the sample names
names(derepFs) <- sample.names
names(derepRs) <- sample.names
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Sample Inference
dadaFs <- dada(derepFs, 
               err = errF, 
               multithread = TRUE)

dadaRs <- dada(derepRs, 
               err = errR, 
               multithread = TRUE)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Merge paired reads
mergers <- mergePairs(dadaFs, 
                      derepFs, 
                      dadaRs, 
                      derepRs,
                      minOverlap = 16,
                      verbose=TRUE)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Construct Sequence Table
seqtab <- makeSequenceTable(mergers)
dim(seqtab)
```

```{r,message=FALSE, warning=FALSE, echo=FALSE,include=FALSE, eval = FALSE}
#Remove chimeras
seqtab.nochim <- removeBimeraDenovo(seqtab, 
                                    method="consensus", 
                                    multithread=TRUE, 
                                    verbose=TRUE)
```

```{r,message=FALSE, warning=FALSE, echo=FALSE,include=FALSE, eval = FALSE}
#Track reads through the pipeline
getN <- function(x) sum(getUniques(x))

track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, 
    getN), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", 
    "nonchim")
rownames(track) <- sample.names
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Distribution of sequence lengths:
table(nchar(getSequences(seqtab.nochim)))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
table(nchar(getSequences(seqtab)))
```


>The frequency of chimeric sequences varies substantially from dataset to dataset, and depends on on factors including experimental procedures and sample complexity. 
```{r message=FALSE, warning=FALSE}
sum(seqtab.nochim)/sum(seqtab)
```

### Inspect distribution of sequence lengths: \

As expected, quite a bit of length variability in the the amplified ITS region.

```{r,fig.cap="Distribution of sequence lengths.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
ggsave("./PLOTS/Full_Data/QC/5-lengh_Distribution.pdf")
hist(nchar(getSequences(seqtab.nochim)), main="Distribution of sequence lengths")
dev.off()

```

### Track reads through the pipeline \
We now inspect the the number of reads that made it through each step in the pipeline to verify everything worked as expected.

```{r,fig.cap="Track Reads.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
#head(track)
ma <- data.matrix(track)
ggsave("./PLOTS/Full_Data/QC/6-track_reads.pdf")
barplot((track), main ="Track Reads", font.axis = 1, cex.axis=1, beside=TRUE, ylim=range(pretty(c(0,track))))
#hist(seqComplexity(seqtab.nochim), 100)
dev.off()

```

Looks good! We kept the majority of our raw reads. The most impacting was the filter step.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Assign taxonomy
unite.ref <- "/Users/juliana/Documents/NBIS/Projects/6198/database/sh_general_release_10.05.2021/sh_general_release_dynamic_10.05.2021.fasta"  # CHANGE ME to location on your machine
taxa <- assignTaxonomy(seqtab.nochim, 
                       unite.ref, 
                       multithread = TRUE, 
                       tryRC = TRUE)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Inspecting the taxonomic assignments:
taxa.print <- taxa  # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#### giving seq headers more manageable names (ASV_1, ASV_2...)####
asv_seqs <- colnames(seqtab.nochim)
asv_headers <- vector(dim(seqtab.nochim)[2], mode="character")

for (i in 1:dim(seqtab.nochim)[2]) {
  asv_headers[i] <- paste(">ASV", i, sep="_")
}
asv_tax <- taxa
row.names(asv_tax) <- sub(">", "", asv_headers)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Construct phylogenetic tree
#Exporting seqs
seqs <- getSequences(taxa)
names(seqs) <- seqs # This propagates to the tip labels of the tree
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA)
phang.align <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phang.align)
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit = pml(treeNJ, data=phang.align)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, 
                    model="GTR", 
                    optInv=TRUE, 
                    optGamma=TRUE,
                    rearrangement = "stochastic", 
                    control = pml.control(trace = 0))
detach("package:phangorn", unload=TRUE)

```


```{r,echo=FALSE,include=FALSE, eval = FALSE}
####Phyloseq Object####
sample_info_tab <- read.table("/Users/juliana/Documents/NBIS/Projects/6198/Metadado/metadata.tsv", header=T, row.names=1,
                              check.names=F, sep="\t")

pseq <- phyloseq(tax_table(taxa), 
sample_data(sample_info_tab),
otu_table(seqtab.nochim, taxa_are_rows = FALSE),
seqs)#,

# pseqTSTE <- phyloseq(tax_table(taxa), 
# sample_data(sample_info_tab),
# otu_table(seqtab.nochim, taxa_are_rows = FALSE),
# seqs, phy_tree(fitGTR$tree))


#phy_tree(fitGTR$tree)) Not addede
taxa_names(pseq) <- paste0("ASV", seq(ntaxa(pseq)))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Exporting files
uniquesToFasta(getUniques(seqtab.nochim), "seqtab.nochim.fasta", ids=paste0("ASV", seq(length(getUniques(seqtab.nochim)))))
export <- t(seqtab.nochim)
rownames(export) = paste0("ASV", seq(length(getUniques(seqtab.nochim))))
export2 <- cbind('#ASVID' = rownames(export), export)
write.table(export, "otu_table.dada.nochim.txt", sep='\t', row.names=FALSE, quote=FALSE)
write.table(taxa, "taxa_table.dada.nochim.txt", sep='\t', row.names=FALSE, quote=FALSE)
write.table(track, "track.txt", sep='\t', row.names=FALSE, quote=FALSE)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Preparing for filter
physeq <- subset_taxa(pseq, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
ps0 <- physeq %>% subset_taxa( Family!= "mitochondria" | is.na(Family) & Class!="Chloroplast" | is.na(Class))
ps = filter_taxa(ps0, function(x) sum(x > 1) > (0.00*length(x)), TRUE)
```

```{bash,echo=FALSE,include=FALSE, eval = FALSE}
#Running ITSx
 ITSx -i seqtab.nochim.fasta -save_regions ITS1  -o ASVs.ITS1
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#ITSx Filter
#Prune taxa in phyloseq object based on ITSX results  
good_taxas <- read.table(file="/Users/juliana/Documents/NBIS/Projects/6198/Working/Lulu/ITS_Final/good_taxa_ITS1",sep="\t", header=FALSE, stringsAsFactors = FALSE) 
str(good_taxa)
good_taxa <- as.vector(unlist(good_taxas))
#Keep good taxa
#prune original ps object by bad taxa and rename to new ps object
ps
allTaxa2 <- taxa_names(ps)
allTaxa2 <- allTaxa2[(allTaxa2 %in% good_taxa)]
ps_ITS <- prune_taxa(allTaxa2, ps)
ps_ITS
```


```{bash,echo=FALSE,include=FALSE, eval = FALSE}
#LULU

#use local blast installed on computer through the Shell for the match steps
#if you haven't already done so, install local blast
#download from ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/

#open Tool/Shell from R Studio
#make blast database from your refseq file
#note that the path specification is needed if the working directory in the shell differs from the filepath
makeblastdb -in ASVs.ITS1.fasta -parse_seqids -dbtype nucl
#makeblastdb -in ASVs.ITS1.fasta -parse_seqids -dbtype nucl
#blast the ASVs against the database
blastn -db ASVs.ITS1.fasta -outfmt "6 qseqid sseqid pident" -out match_list.txt -qcov_hsp_perc 80 -perc_identity 84 -query seqtab.nochim.fasta

```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Preparing files to Lulu
# Extract abundance matrix from the phyloseq object
OTU1 = as(otu_table(ps_ITS), "matrix")
# transpose if necessary
if(taxa_are_rows(ps_ITS)){OTU1 <- t(OTU1)}
# Coerce to data.frame
OTUdf = as.data.frame(t(OTU1))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Running Lulu
#read in match file from local blast
matchlist <- read.csv(file="/Users/juliana/Documents/NBIS/Projects/6198/Working/Lulu/LULU_Pos_ITS/match_list.txt",sep="\t", header=FALSE, stringsAsFactors = FALSE) 
str(matchlist)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Checking results LULU
curated_result <- lulu(OTUdf, matchlist)
curated_result$curated_table
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#save lulu results
ASVtablelulu <- curated_result$curated_table
write.csv(ASVtablelulu, "/Users/juliana/Documents/NBIS/Projects/6198/Working/Lulu/LULU_Pos_ITS/ASVs_table_lulu.csv")

ASVlulu_discards <- curated_result$discarded_otus
write.csv(ASVlulu_discards, "/Users/juliana/Documents/NBIS/Projects/6198/Working/Lulu/LULU_Pos_ITS/filt_lulu_discards.csv")

ASVlulu_retained <- curated_result$curated_otus
write.csv(ASVlulu_retained, "/Users/juliana/Documents/NBIS/Projects/6198/Working/Lulu/LULU_Pos_ITS/filt_lulu_retained.csv")
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Lulu
#check counts curated and removed
curated_result$curated_count
curated_result$discarded_count
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Prune taxa in phyloseq object based on lulu results  
#Open discarded taxa file from lulu and convert from data.frame to vector
badTaxa_v <- ASVlulu_discards
#note: alternatively, could use the retained file to subset
#prune original ps object by bad taxa and rename to new ps object
ps_ITS
allTaxa <- taxa_names(ps_ITS)
allTaxa <- allTaxa[!(allTaxa %in% badTaxa_v)]
ps_lulu2 <- prune_taxa(allTaxa, ps_ITS)
ps_lulu2
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
# Compute prevalence of each feature, store as data.frame
prevdf = apply(X = otu_table(ps_lulu2),
                 MARGIN = ifelse(taxa_are_rows(ps_lulu2), yes = 1, no = 2),
                 FUN = function(x){sum(x > 0)})
# Add taxonomy and total read counts to this data.frame
prevdf = data.frame(Prevalence = prevdf,
                      TotalAbundance = taxa_sums(ps_lulu2),
                      tax_table(ps_lulu2))
plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))})

```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
# Define phyla to filter
filterPhyla = c("p__Calcarisporiellomycota")
# Filter entries with unidentified Phylum.
ps1 = subset_taxa(ps_lulu2, !Phylum %in% filterPhyla)
ps1

```


### Taxa prevalence versus total counts.

```{r,fig.cap="Taxa prevalence.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
# Subset to the remaining phyla
prevdf1 = subset(prevdf, Phylum %in% get_taxa_unique(ps1, "Phylum"))

phylum_plot <- ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(ps0),color=Phylum)) +
  # Include a guess for parameter
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) + geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
phylum_plot
ggsave("./PLOTS/Full_Data/QC/7-Taxa_prevalence.pdf", phylum_plot)

```

Each point is a different taxa. Exploration of the data in this way is often useful for selecting filtering parameters, like the minimum prevalence criteria we will used to filter the data above.

>In this study, I removed taxa not seen more than 2 times in at least 1% of the samples. This protects against an ASV with small mean & trivially large C.V.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Remove taxa not seen more than 2 times in at least 1% of the samples. This protects against an OTU with small mean & trivially large C.V.
ps2 = filter_taxa(ps1, function(x) sum(x > 2) > (0.01*length(x)), TRUE)
#  Count prevalence
length(get_taxa_unique(ps2, taxonomic.rank = "Genus"))
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
# Taxonomy table -> Renamed for plot
pseq_taxa_df = data.frame(ps2@tax_table, stringsAsFactors = F)
pseq_taxa_df[is.na(pseq_taxa_df)]<- 'Unknown'
pseq_taxa_df$Genus_name = pseq_taxa_df$Genus
pseq_taxa_df$Species_name = pseq_taxa_df$Species
# Replace NA Genus_name column values
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- pseq_taxa_df$Family[which(pseq_taxa_df$Genus_name=='Unknown')]
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- pseq_taxa_df$Order[which(pseq_taxa_df$Genus_name=='Unknown')]
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- pseq_taxa_df$Class[which(pseq_taxa_df$Genus_name=='Unknown')]
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- pseq_taxa_df$Phylum[which(pseq_taxa_df$Genus_name=='Unknown')]
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- pseq_taxa_df$Kingdom[which(pseq_taxa_df$Genus_name=='Unknown')]
pseq_taxa_df$Genus_name[which(pseq_taxa_df$Genus_name=='Unknown')] <- 'Unknown'
# Generate a column with row number
pseq_taxa_df$ASV_id <- paste('[',seq.int(nrow(pseq_taxa_df)), ']', sep="")
pseq_taxa_df$ASV <- row.names(pseq_taxa_df)
# Replace Unknown Species_name
pseq_taxa_df$Species_name[which(pseq_taxa_df$Species_name=='Unknown')] <- ""
# Remove .
pseq_taxa_df$Species_name = stringr::str_replace(pseq_taxa_df$Species_name,"\\.", "/")
pseq_taxa_df$Species_name = stringr::str_replace(pseq_taxa_df$Species_name,"//", "/")
# If Species has more than 3 possible names, remove them
multiaffiliation_species<-which(lengths(strsplit(pseq_taxa_df$Species_name, "/"))>3)
pseq_taxa_df$Species_name[multiaffiliation_species] <- ""
# Combine Genus and Species name
pseq_taxa_df$Genus_Species_name = paste(pseq_taxa_df$Genus_name, pseq_taxa_df$Species_name)
pseq_taxa_df$Genus_Species_name <- trim.trailing(pseq_taxa_df$Genus_Species_name)
pseq_taxa_df$taxa_name = paste(pseq_taxa_df$Genus_Species_name, pseq_taxa_df$OTU_id)
pseq_taxa_df$taxa_name = stringr::str_replace_all(pseq_taxa_df$taxa_name,"\\_", " ")
pseq_taxa_df[, c('Genus_name', 'Species_name', 'Genus_Species_name')] = list(NULL)
tax_table(ps2) <- as.matrix(pseq_taxa_df)
#Exporting
write_phyloseq(ps2, type = "TAXONOMY")
write_phyloseq(ps2, type = "METADATA")
write_phyloseq(ps2, type = "OTU")
#saveRDS(ps2, "Final_met_Tax.rds") 
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Voltar daqui! Inicio
#ps_new <- ps2: taxonomy fixed by hand = 3652 taxa
pseq <- ps_new
summarize_phyloseq(ps_new)
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#  Count prevalence
#rank_names(pseq)
length(get_taxa_unique(pseq, taxonomic.rank = "Kingdom")) #1
length(get_taxa_unique(pseq, taxonomic.rank = "Phylum")) #15
length(get_taxa_unique(pseq, taxonomic.rank = "Class")) #53
length(get_taxa_unique(pseq, taxonomic.rank = "Order")) #128
length(get_taxa_unique(pseq, taxonomic.rank = "Family")) #232
length(get_taxa_unique(pseq, taxonomic.rank = "Genus")) #458
length(get_taxa_unique(pseq, taxonomic.rank = "Species")) #551

```


> **Count prevalence** \
> - **Kingdom** = 1\
>-- **Phylum** = 15\
>--- **Class** = 53\
>--- **Order** = 128\
>---- **Family** = 232\
>----- **Genus** = 458\
>------ **ASVs** = 551

## Replicates Evaluation

In this step an evaluation of the replicates has been performed. The main goal was to understand if they are any significant difference between the replicates A and B.

**Alpha Diversity Plot comparing the Replicates A and B.**

>Quality control analysis using matched samples from 3 different Transects: A, B and C of the experiment and replicates samples on each Ecotype.
Comparison of alpha diversity in technical replicates samples on all Ecotypes from each Transect. ASV richness and ASV Shannon diversity.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Def Colors
cols_Type <- c("A" = "#264D59", "B" = "#77A515")
cols_Ecotype <- c("Meadow" = "#D46C4E", "Spruce-Alder" = "#77A515", "Spruce" = "#264D59", "Alder" = "#43978D", "Pine" = "#d49c4e")
cols_Ecotype2 <- c("I", "II", "III","IV","V")
cols_Transect <- c("1" = "#264D59", "2" = "#77A515", "3" = "#D46C4E")
```

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Alpha Diversity
pseq <- ps_new
reads_sample <- readcount(pseq)
# check for first 5 samples
reads_sample[1:5]
sample_data(pseq)$Reads_Sample <- reads_sample
#
alpha_diversity <- estimate_richness(pseq,  measures = c("Shannon", "Observed"))
df <- data.frame(alpha_diversity, sample_data(pseq))
df$Transect <- factor(df$Transect, levels = c(1,2,3), labels = c("1","2", "3")) #Keep 1,2,3
df$Ecotype <- factor(df$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))
#df$Ecotype <- factor(df$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("I", "II", "III","IV","V"))
```

```{r,fig.cap="Alpha Diversity.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE}
##Plot measures
dose.labs <- c("Richness", "Shannon")
names(dose.labs) <- c("Observed", "Shannon")
#Scale
scales <- list(
  scale_y_continuous(limits = c(0,500)
            ))
#
options(ggrepel.max.overlaps = Inf)
plot_alpha1 <- df %>% 
  gather(key = metric, value = value, c("Observed", "Shannon")) %>%
  mutate(metric = factor(metric, levels = c("Observed", "Shannon"))) %>%
  ggplot(aes(x = Ecotype, y = value, color = Ecotype)) + #,shape = Type
  #geom_point(size=4) +
  #geom_boxplot(outlier.color = NA) +
  geom_violin(draw_quantiles = c( 0.5)) +
  geom_jitter(aes(color = Ecotype), height = 0, width = .2) +
  geom_text_repel(aes(label = Type), nudge_x = 0.06, size = 3.0, segment.alpha = 0.5) +
  labs(x = "", y = "") +
  theme_pubr(border = TRUE) +
  scale_colour_manual(values = cols_Ecotype) +
  theme(legend.position="top") +
  theme(legend.title = element_blank()) +
  facet_nested(metric~Transect, labeller=labeller(metric = dose.labs), scales = "free") +
  facetted_pos_scales(y = scales) 
plot_alpha1

ggsave("./PLOTS/Full_Data/Evaluation/00-plot_alpha1.pdf", plot_alpha1, width = 14.5, height = 7.58)

```
>Evaluation of alpha diversity: looking for difference at the count read distribution

```{r,fig.cap="Alpha Diversity Count.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
options(ggrepel.max.overlaps = Inf)

alpha_count<- df %>% 
  gather(key = metric, value = value, c("Observed", "Shannon")) %>%
  mutate(metric = factor(metric, levels = c("Observed", "Shannon"))) %>%
  ggplot(aes(x = Ecotype, y = value, color = Ecotype, shape = Type,group=interaction(Transect, Ecotype))) +
  geom_point(size=4) + 
  #geom_line() +
  geom_text_repel(aes(label = Reads_Sample), nudge_x = 0.06, size = 3.0, segment.alpha = 0.5) +
  theme_pubr(border = TRUE) +
  theme(axis.text=element_text(size=14), 
        axis.text.x = element_text(size = 12, hjust = 0.5), 
        axis.title.y = element_text(size = 18),
        legend.text=element_text(size=8),
        legend.position = "none") +
  scale_colour_manual(values = cols_Ecotype) + 
  #scale_x_discrete(limits=c("Before", "After")) +
  labs(x = "", y = "") +
  theme(legend.position="top")+
  theme(legend.title = element_blank()) +
  facet_nested(metric~Transect, labeller=labeller(metric = dose.labs), scales = "free_y", space = "free_x") +
  facetted_pos_scales(y = scales)

ggsave("./PLOTS/Full_Data/Evaluation/00-plot_alpha_count.pdf", alpha_count, width = 14.5, height = 7.58)

```

**Beta Diversity Plot comparing the Replicates A and B.**

Quality control analysis using matched samples from replicates A and B. Beta diversity using Jensen-Shannon distance 


```{r,fig.cap="Beta Diversity Distance",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
##Replicates
#Filter all samples with triplicates
Replicates <- subset_samples(pseq, Type =="A" | Type=="B")
#Relative Abundance
Replicates_R <- transform_sample_counts(Replicates, function(otu) otu/sum(otu))
jsd_dist<- sqrt(phyloseq::distance(Replicates_R, "jsd"))
pcoa_jsd <- ordinate(Replicates_R, method = "PCoA", distance = jsd_dist)
#
exptT = prune_taxa(names(sort(taxa_sums(Replicates_R), TRUE)), Replicates_R)
ordT2<- sqrt(phyloseq::distance(Replicates_R,Type = "samples", "jsd"))
pcoa=ordinate(Replicates_R, "PCoA", distance=ordT2)
#
a<-pcoa$values
b<-as.data.frame(pcoa$vectors)
samdf<-data.frame(unclass(Replicates_R@sam_data))
row.names(samdf)<-sample_names(Replicates_R)
#
distance_matrix<-matrix(jsd_dist)
distance_matrix<-as.matrix(jsd_dist)
distance_matrix<-as.data.frame(distance_matrix)
distance_matrix <-(distance_matrix)
#
compALL_T <-c("P9723_1025_S25_L001.P9723_1029_S29_L001","P9723_1033_S33_L001.P9723_1037_S37_L001","P9723_1041_S41_L001.P9723_1045_S45_L001","P9723_1001_S1_L001.P9723_1005_S5_L001","P9723_1009_S9_L001.P9723_1013_S13_L001","P9723_1017_S17_L001.P9723_1021_S21_L001","P9723_1002_S2_L001.P9723_1006_S6_L001","P9723_1010_S10_L001.P9723_1014_S14_L001","P9723_1018_S18_L001.P9723_1022_S22_L001","P9723_1073_S73_L001.P9723_1077_S77_L001","P9723_1081_S81_L001.P9723_1085_S85_L001","P9723_1089_S89_L001.P9723_1093_S93_L001","P9723_1049_S49_L001.P9723_1053_S53_L001","P9723_1065_S65_L001.P9723_1069_S69_L001","P9723_1050_S50_L001.P9723_1054_S54_L001","P9723_1058_S58_L001.P9723_1062_S62_L001","P9723_1066_S66_L001.P9723_1070_S70_L001","P9723_1026_S26_L001.P9723_1030_S30_L001","P9723_1034_S34_L001.P9723_1038_S38_L001","P9723_1042_S42_L001.P9723_1046_S46_L001","P9723_1027_S27_L001.P9723_1031_S31_L001","P9723_1035_S35_L001.P9723_1039_S39_L001","P9723_1043_S43_L001.P9723_1047_S47_L001","P9723_1011_S11_L001.P9723_1015_S15_L001","P9723_1019_S19_L001.P9723_1023_S23_L001","P9723_1074_S74_L001.P9723_1078_S78_L001","P9723_1082_S82_L001.P9723_1086_S86_L001","P9723_1090_S90_L001.P9723_1094_S94_L001","P9723_1075_S75_L001.P9723_1079_S79_L001","P9723_1083_S83_L001.P9723_1087_S87_L001","P9723_1091_S91_L001.P9723_1095_S95_L001","P9723_1051_S51_L001.P9723_1055_S55_L001","P9723_1059_S59_L001.P9723_1063_S63_L001","P9723_1067_S67_L001.P9723_1071_S71_L001","P9723_1052_S52_L001.P9723_1056_S56_L001","P9723_1060_S60_L001.P9723_1064_S64_L001","P9723_1068_S68_L001.P9723_1072_S72_L001","P9723_1028_S28_L001.P9723_1032_S32_L001","P9723_1036_S36_L001.P9723_1040_S40_L001","P9723_1044_S44_L001.P9723_1048_S48_L001","P9723_1012_S12_L001.P9723_1016_S16_L001","P9723_1020_S20_L001.P9723_1024_S24_L001")
#
distance_matrix$samples<-row.names(distance_matrix)
distance_matrix_melt<-melt.data.frame(distance_matrix, id.vars = "samples")
distance_matrix_melt$Comparision<-paste(distance_matrix_melt$samples, distance_matrix_melt$variable, sep = ".")
distance_matrix_melt_filt<-subset(distance_matrix_melt, Comparision %in% compAll_T)
row.names(distance_matrix_melt_filt)<-as.character(distance_matrix_melt_filt$variable)
distance_matrix_melt_filt_info<-merge(distance_matrix_melt_filt, samdf, by=0)
#Factor
distance_matrix_melt_filt_info$Transect <- factor(distance_matrix_melt_filt_info$Transect, levels = c(1,2,3), labels = c("1","2", "3"))
distance_matrix_melt_filt_info$Ecotype <- factor(distance_matrix_melt_filt_info$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))
#
Beta_Replicates <- ggplot(distance_matrix_melt_filt_info, aes(Ecotype, value, shape = Type)) +
  geom_jitter(shape=16, size = 5, position=position_jitter(0.2), color = "black", alpha = 0.7) +
  geom_text_repel(aes(label = User_ID), nudge_x = 0.02, size = 4.0, segment.alpha = 0.5) +
  theme_pubr(border = TRUE) +
  facet_grid(~Transect) +
  theme(axis.text=element_text(size=12), 
        axis.text.x = element_text(size = 12, hjust = 0.5), 
        axis.title.y = element_text(size = 12, hjust = 0.5),
        legend.text=element_text(size=12), 
        legend.title=element_text(size=0),
        legend.position="none",
        axis.title.x = element_text(size = 12), 
        strip.text.x = element_text(size = 12, face = "bold"),
        strip.text.y = element_text(size = 12, face = "bold")) +
  labs(x="Ecotype", y = "Jensen-Shannon Distance (JSD)") +
  ylim(0, 1) 
print(Beta_Replicates)

ggsave("./PLOTS/Full_Data/Evaluation/02-Plot_beta_distance.pdf", Beta_Replicates, width = 14.5, height = 7.58)
```

**Beta Diversity Plot comparing the Replicates A and B.**

```{r,echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
##PCOA
##Relative Abundance

genefilter_pseq = genefilter_sample(pseq, filterfun_sample(function(x) x > 5), A=0.5*nsamples(pseq))

genefilter_pseq_tax = prune_taxa(genefilter_pseq, pseq)

#Transform to even sampling depth.
genefilter_pseq_tax_t = transform_sample_counts(genefilter_pseq_tax, function(x) 1E6 * x/sum(x))

genefilter_pseq_tax_t.ord <- ordinate(genefilter_pseq_tax_t, "NMDS")

#
genefilter_pseq_tax_t@sam_data$Transect <- factor(genefilter_pseq_tax_t@sam_data$Transect, levels = c(1,2,3), labels = c("1","2", "3"))

#Type

genefilter_pseq_tax_t@sam_data$Ecotype <- factor(genefilter_pseq_tax_t@sam_data$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))

#
ord_DataFrame_tx_pseq <- plot_ordination(genefilter_pseq_tax_t, genefilter_pseq_tax_t.ord, "samples", justDF ="TRUE")
```

```{r,fig.cap="Beta Diversity Replicates.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
ggsave("./PLOTS/Full_Data/Evaluation/03-Beta_Diversity.pdf")
ordplot_tx_pseq <- (ordplot_pseq <- plot_ordination(genefilter_pseq_tax_t, genefilter_pseq_tax_t.ord, "samples", color="Ecotype", shape = "Transect") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
              geom_text_repel(aes(label = Type), nudge_x = 0.06, size = 3.0, segment.alpha = 0.5) +

               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Ecotype)#+
ordplot_tx_pseq$layers <- ordplot_tx_pseq$layers[-1]
ordplot_tx_pseq + 
  geom_point(data=ord_DataFrame_tx_pseq, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) 
dev.off()
```

```{r,fig.cap="Beta Diversity Replicates by Type.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}

ggsave("./PLOTS/Full_Data/Evaluation/04-Beta_Diversity.pdf")

ordplot_tx_pseq2 <- (ordplot_pseq_2 <- plot_ordination(genefilter_pseq_tax_t, genefilter_pseq_tax_t.ord, "samples", color="Ecotype", shape = "Transect") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Ecotype)#+
ordplot_tx_pseq$layers <- ordplot_tx_pseq$layers[-1]
ordplot_tx_pseq + 
  geom_point(data=ord_DataFrame_tx_pseq, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) +
  facet_grid(~Type)

dev.off()
```

>In summary: there is no difference between A and B samples. In this way we choose working the replicate A.

```{r,echo=FALSE,include=FALSE, eval = FALSE}
#Removing replicates 
P_Plots <- subset_samples(pseq, Main_Analysis =="Yes")
```

Rarefaction
```{r,fig.cap="Rarefaction.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
psdata = rarefy_even_depth(P_Plots)
plot(as(otu_table(psdata), 'vector'), as(otu_table(psdata), 'vector'))
rarecurve(t(otu_table(psdata)), step=50, cex=0.5)
rarecurve(t(otu_table(P_Plots)), step=50, cex=0.5)

```


## Main Analysis

* Alpha Diversity Plot - A.

Raw **alpha-diversity**, i.e. without rarefying

- comparing alpha diversity based on raw data has the huge problem of ignoring sample size differences. Usually there is a trend that more reads correlate with higher diversity.
- Here, therefore I checked, whether there are significant sample size differences between the groups. 
- We further look at the residuals of a linear fit alpha diversity vs sample size to correct for this confounder.

- Check whether sample_sums/sample sizes/library sizes differ between groups

- sample size adjustment has no influence on richness, so sample_sizes are compared for raw counts


```{r,echo=FALSE,include=FALSE}
#Alpha Diversity
P_Plots
reads_sample <- readcount(P_Plots)
# check for first 5 samples
reads_sample[1:5]
sample_data(P_Plots)$Reads_Sample <- reads_sample
#
alpha_diversityb <- estimate_richness(P_Plots,  measures = c("Shannon", "Observed"))
#alpha_diversityb <- estimate_richness(P_Plots,  measures = c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher"))
df2 <- data.frame(alpha_diversityb, sample_data(P_Plots))
df2$Transect <- factor(df2$Transect, levels = c(1,2,3), labels = c("1","2", "3")) #Keep 1,2,3
df2$Ecotype <- factor(df2$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))

```


```{r,fig.cap="AlphaDiversity Main Analysis.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
##Plot measures
PY <- levels(df2$Ecotype) # get the variables
PY.pairs <- combn(seq_along(PY), 2, simplify = FALSE, FUN = function(i)PY[i])

dose.labs <- c("Richness", "Shannon")
names(dose.labs) <- c("Observed", "Shannon")

#dose.labs <- c("Richness", "Chao1", "se.chao1", "ACE", "se.ACE", "Shannon", "Simpson","InvSimpson", "Fisher")
#names(dose.labs) <- c("Observed", "Chao1", "se.chao1", "ACE", "se.ACE", "Shannon", "Simpson","InvSimpson", "Fisher")

#Scale
scales <- list(
  scale_y_continuous(limits = c(0,500)
            ))

##
options(ggrepel.max.overlaps = Inf)
p <- df2 %>% 
gather(key = metric, value = value, c("Observed", "Shannon")) %>%
#gather(key = metric, value = value, c("Observed", "Chao1", "se.chao1", "ACE", "se.ACE", "Shannon", "Simpson","InvSimpson", "Fisher")) %>%
mutate(metric = factor(metric, levels = c("Observed", "Shannon"))) %>%
#mutate(metric = factor(metric, levels = c("Observed", "Chao1", "se.chao1", "ACE", "se.ACE", "Shannon", "Simpson","InvSimpson", "Fisher"))) %>%
  ggplot(aes(x = Ecotype, y = value, color = Ecotype)) + #,shape = Type
  geom_point(size = 5, color = "grey") +
  labs(x = "", y = "") +
  theme_pubr(border = TRUE) +
  scale_colour_manual(values = cols_Ecotype) +
  theme(legend.position="top") +
  theme(legend.title = element_blank()) +
  facet_nested(metric~Transect, labeller=labeller(metric = dose.labs), scales = "free") +
  facetted_pos_scales(y = scales) 
p + 
  geom_point(data=p$data, aes(x = Ecotype, y = value, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) 
#Rplot_AlphaDiversity_MainAnalysis
```

Alpha Diversity = BoxPlot

```{r,fig.cap="AlphaDiversity Main Analysis.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
options(ggrepel.max.overlaps = Inf)
PYpb <- levels(df2$Transect) # get the variables
PY.pairspb <- combn(seq_along(PYpb), 2, simplify = FALSE, FUN = function(i)PYpb[i])
pb <- df2 %>% 
  gather(key = metric, value = value, c("Observed", "Shannon")) %>%
  mutate(metric = factor(metric, levels = c("Observed", "Shannon"))) %>%
  ggplot(aes(x = Transect, y = value, color = Transect)) +
  geom_boxplot(outlier.color = NA) +
  geom_jitter(aes(color = Ecotype), height = 0, width = .2) +
  labs(x = "", y = "") +
  theme_pubr(border = TRUE) +
  scale_colour_manual(values = cols_Transect) +
  theme(legend.position="top") +
  theme(legend.title = element_blank()) +
  facet_nested(metric~Ecotype, labeller=labeller(metric = dose.labs), scales = "free") +
  facetted_pos_scales(y = scales) +
  stat_compare_means( method='wilcox.test', p.adjust.method = "BH", label = "p.signif", comparisons = PY.pairspb, size = 2) 
pb
```

```{r}
#https://grunwaldlab.github.io/analysis_of_microbiome_community_data_in_r/07--diversity_stats.html
anova_result <- aov(df2$Observed ~ Transect * Ecotype, data = df2)
summary(aov(df2$Observed ~ Transect * Ecotype, data = df2))
aresult <- HSD.test(anova_result, "Ecotype", group = TRUE)
```

**Plot by mean**

```{r,include=FALSE}
#plot by mean
#Observed
tt <- aggregate(df2$Observed, list(df2$Transect, df2$Ecotype), FUN=mean)
names(tt)[1] <- "Transect"
names(tt)[2] <- "Ecotype"
names(tt)[3] <- "Observed"

#Evenness
H <- df2$Shannon
S1 <- df2$Observed
S <- log(S1)
evenness <- H/S

#Shannon
Shannon <- aggregate(df2$Shannon, list(df2$Transect, df2$Ecotype), FUN=mean)
 
# Chao1 <- aggregate(df2$Chao1, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# se.chao1 <- aggregate(df2$se.chao1, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# ACE <- aggregate(df2$ACE, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# se.ACE <- aggregate(df2$se.ACE, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# Simpson <- aggregate(df2$Simpson, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# InvSimpson <- aggregate(df2$InvSimpson, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# Fisher <- aggregate(df2$Fisher, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# Observed <- aggregate(df2$Observed, list(df2$Transect, df2$Ecotype), FUN=mean)
# 
# tt <- df2 %>% 
#   group_by(Transect,Ecotype) %>% 
#   summarise (Observed = mean(Observed))
# 
# tt2 <- df2 %>% 
#   group_by(Transect,Ecotype) %>% 
#   summarise (Shannon = mean(Shannon))

#write.table(df2, "/Users/juliana/Documents/GitHub/SMS-6198-22-ITS/results/DF_Main_Data.tsv", sep='\t', row.names=FALSE, quote=FALSE)
```

```{r,fig.cap="AlphaDiversity Main Analysis.",  fig.width = 14.5, fig.height = 7.58, echo=FALSE, warning=FALSE, message=FALSE}
PY4 <- levels(tt$Ecotype) # get the variables
PY.pairs4 <- combn(seq_along(PY4), 2, simplify = FALSE, FUN = function(i)PY4[i])

##
options(ggrepel.max.overlaps = Inf)
p4 <- tt %>% 
  ggplot(aes(x = Ecotype, y = Observed, color = Ecotype)) + #,shape = Type
  geom_point(size = 5, color = "grey") +
  labs(x = "", y = "") +
  theme_pubr(border = TRUE) +
  scale_colour_manual(values = cols_Ecotype) +
  theme(legend.position="top") +
  theme(legend.title = element_blank()) +
  facet_nested(~Transect) +
  stat_compare_means( method='wilcox.test', p.adjust.method = "BH", label = "p.signif", comparisons = PY.pairs4, size = 2) 

p4 + 
  geom_point(data=p4$data, aes(x = Ecotype, y = Observed, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) 
```


```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE}

##
options(ggrepel.max.overlaps = Inf)
p5 <- tt %>% 
  ggplot(aes(x = Ecotype, y = Observed, color = Transect)) + #,shape = Type
  geom_point(size = 5, color = "grey") +
  labs(x = "", y = "") +
  theme_pubr(border = TRUE) +
  scale_colour_manual(values = cols_Transect) +
  theme(legend.position="top") +
  theme(legend.title = element_blank()) 
p5 + 
  geom_point(data=p5$data, aes(x = Ecotype, y = Observed, fill =Transect, size = 4))  +
  scale_fill_manual(values = cols_Transect) 
```

* Beta Diversity Plot - A.


```{r}
gpca  <- ordinate(Plots, "MDS")
# Scree plot
plot_scree(gpca, "Scree Plot for MDS Analysis")
```
```{r}
#Remove ASVs that do not show appear more than 5 times in more than half the samples
genefilter = genefilter_sample(P_Plots, filterfun_sample(function(x) x > 5), A=0.5*nsamples(P_Plots))
genefilter_tax = prune_taxa(genefilter, P_Plots)

#Transform to even sampling depth.
genefilter_tax_t = transform_sample_counts(genefilter_tax, function(x) 1E6 * x/sum(x))

genefilter_tax_t.ord <- ordinate(genefilter_tax_t, "NMDS")

#
genefilter_tax_t@sam_data$Transect <- factor(genefilter_tax_t@sam_data$Transect, levels = c(1,2,3), labels = c("1","2", "3"))

genefilter_tax_t@sam_data$Ecotype <- factor(genefilter_tax_t@sam_data$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))

#
ord_DataFrame_tx <- plot_ordination(genefilter_tax_t, genefilter_tax_t.ord, "samples", justDF ="TRUE")

#
ordplot_tx <- (ordplot <- plot_ordination(genefilter_tax_t, genefilter_tax_t.ord, "samples", color="Ecotype", shape = "Transect") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Ecotype)#+
ordplot_tx$layers <- ordplot_tx$layers[-1]
ordplot_tx + 
  geom_point(data=ord_DataFrame_tx, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) 

```


```{r}
pord2 = (ordplot <- plot_ordination(genefilter_tax_t, genefilter_tax_t.ord, "samples", color="Ecotype", shape = "Transect") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               geom_polygon(aes(fill=Ecotype, alpha = 0.8)) + 
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Ecotype)

pord2$layers <- pord2$layers[-1]
pord2 + 
  geom_point(data=ord_DataFrame_tx, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype) 

```

* Beta Diversity Plot - B.

```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE}
ordplot3 <- (ordplot <- plot_ordination(genefilter_tax_t, genefilter_tax_t.ord, "samples", color="Ecotype") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Ecotype)+
  facet_grid(~Transect)

ordplot3$layers <- ordplot3$layers[-1]
ordplot3 + 
  geom_point(data=ord_DataFrame_tx, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Ecotype)
```

Ecotype
```{r, fig.width = 14.5, fig.height = 7.58, echo=FALSE}
ordplot4 <- (ordplot <- plot_ordination(genefilter_tax_t, genefilter_tax_t.ord, "samples", color="Transect") + 
               geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.3) + 
               geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.3) +
               geom_point(size = 5, color = "grey") +
               scale_shape_manual(values=c(23,21,24)) +
               theme_pubr(border = TRUE) +
               coord_fixed(ratio = 1) +
               theme(axis.text=element_text(size=14), 
                     axis.text.x = element_text(size = 12, hjust = 0.5), 
                     axis.title.y = element_text(size = 18),
                     legend.text=element_text(size=14), 
                     legend.title=element_text(size=0),
                     legend.position="bottom",
                     axis.title.x = element_text(size = 18), 
                     strip.text.x = element_text(size = 20, face = "bold"))) +
  scale_color_manual(values = cols_Transect)+
  facet_grid(~Ecotype)

ordplot4$layers <- ordplot4$layers[-1]
ordplot4 + 
  geom_point(data=ord_DataFrame_tx, aes(x = NMDS1, y = NMDS2, fill =Ecotype, size = 4))  +
  scale_fill_manual(values = cols_Transect)
```

* Permutational analysis of variance

```{r, echo=FALSE}
metadata <- as(sample_data(P_Plots), "data.frame")
dist.bc <- phyloseq::distance(P_Plots, method = "bray")
permanova <- adonis2(dist.bc ~ Ecotype + Transect, data = metadata, perm=9999)
permanova
```
HeatMap 


```{r}
#Heatmap 
meta_data_2 <- read.table("/Users/juliana/Documents/NBIS/Projects/6198/Metadado/metadata_copynumber_sampleA.tsv", header=T, row.names=1, check.names=T, sep="\t")
sample_data(P_Plots) <- meta_data_2

P_Plots@sam_data$CopyNumber2 <- as.numeric(P_Plots@sam_data$CopyNumber)


#Remove ASVs that do not show appear more than 3 times in more than 30% the samples
genefilter2 = genefilter_sample(P_Plots, filterfun_sample(function(x) x > 3), A=0.3*nsamples(P_Plots))
genefilter_tax2 = prune_taxa(genefilter2, P_Plots)
#MetaData
metaR <- meta(genefilter_tax2)

# Reorder Transect
metaR$Transect = factor(metaR$Transect, levels = c("1", "2","3")) #D46C4E
metaR_Transect <- c("#C0C0C0","#BC8F8F","#F5DEB3") #D46C4E #43978D
names(metaR_Transect) <- levels(metaR$Transect)

# Reorder Ecotype
metaR$Ecotype <- factor(metaR$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))
metaR_Ecotype <- c("#77A515", "#264D59", "#43978D", "#D46C4E", "#2b8cbe")
names(metaR_Ecotype) <- levels(metaR$Ecotype)

# Add to a list, where names match those in factors dataframe
metaR_AnnColour <- list(
  Transect = metaR_Transect)

metaR_AnnColour2 <- list(
  Ecotype = metaR_Ecotype)

metaR_AnnColourx <- list(
  Transect = metaR_Transect,
  Ecotype = metaR_Ecotype)

# Check the output
metaR_AnnColour

SampleOrder = order(metaR$Ecotype, metaR$Transect)
meta.factors <- select(metaR, Transect, Ecotype)


metaR_Filter_composi.filt.abs <- P_Plots
#Subset #Multiplicando pela soma das reads, normalizando
metaR_Filter_composi.filt.ab <- transform_sample_counts(genefilter_tax2, function(x)100*x/sum(x))

###
{
  for(n in 1:nsamples(metaR_Filter_composi.filt.ab))
    
    otu_table(metaR_Filter_composi.filt.abs)<- otu_table(metaR_Filter_composi.filt.ab)*sample_data(metaR_Filter_composi.filt.ab@sam_data)$CopyNumber [n]
}

abs_plot <- data.frame(otu_table(metaR_Filter_composi.filt.abs))

#Colocando ASV names na OTU table
rownames(abs_plot)
taxonomy_otu_compositional_copy <- data.frame(tax_table(metaR_Filter_composi.filt.abs))
tax_m <- taxonomy_otu_compositional_copy$taxa_name
rownames(abs_plot) <- tax_m
abs_plot

##Plot
plot_Log10_max <- log10(abs_plot)/max(log10(abs_plot) +1)
#plot_Log10_max <- log10(abs_plot +1)
plot_Log10_max[plot_Log10_max == "-Inf"] <- 0

colsHeat<- c("#F7F7F7", "#92C5DE", "#0571B0", "#F4A582", "#CA0020")

pheatmap(plot_Log10_max[, SampleOrder],
         cluster_cols = FALSE,
         cluster_rows = TRUE,
         gaps_row = 5, 
         clustering_distance_rows = "euclidean",
         clustering_distance_cols  = "euclidean",
         annotation_colors = metaR_AnnColourx, annotation_col = meta.factors, 
         show_colnames = FALSE,
         color = colorRampPalette(c("white", colsHeat))(50),
         border_color = "#f8edeb",
         display_numbers = FALSE)


meta.factorsT <- select(metaR, Transect)
meta.factorsE <- select(metaR, Ecotype)


```

```{r}
Taxa_DataFrame <- data.frame(tax_table(metaR_Filter_composi.filt.abs))
Taxa_DataFrame_F <- Taxa_DataFrame %>% select(1,2,3,4,5,6,10)
Taxa_Matrix <- as.matrix(Taxa_DataFrame_F)

pseq_plot_heat <- metaR_Filter_composi.filt.abs

rown <- rownames(sample_data(pseq_plot_heat))
sample_data(pseq_plot_heat)$SampleID <- rown
sample_data(pseq_plot_heat) <- (sample_data(pseq_plot_heat)[, c(14,1,2,3,4,5,6,7,8,9,10,11,12,13)])

tax_table(pseq_plot_heat) <- as.matrix(Taxa_Matrix)

count_f <- data.frame(otu_table(pseq_plot_heat))
meta_f <- data.frame(sample_data(pseq_plot_heat))
taxa_f <- data.frame(tax_table(pseq_plot_heat))
names(taxa_f)[7] <- "Species"


d <- amp_load(
  otutable = count_f,
  metadata = meta_f,
  taxonomy = taxa_f
)



teste <-  amp_heatmap(
  d,
  group_by = c("Transect"),
  facet_by = c("Ecotype"),
  normalise = TRUE,
  #tax_add = "OTU",
  tax_aggregate = "Species",
  tax_show = 100,
  showRemainingTaxa = FALSE,
  tax_class = NULL,
  tax_empty = "best",
  plot_values = FALSE,
  plot_values_size = 3,
  plot_legendbreaks = NULL,
  plot_colorscale = "log10",
  plot_na = TRUE,
  measure = "mean",
  #sort_by = "Transect 1",
  min_abundance = 0.01,
  max_abundance = NULL,
  normalise_by = NULL,
  scale_by = NULL,
  color_vector = colorRampPalette(c("white", colsHeat))(50),
  round = 1,
  textmap = FALSE,
  plot_functions = FALSE,
  function_data = FALSE,
  functions = c("MiDAS", "Filamentous", "AOB", "NOB", "PAO", "GAO"),
  rel_widths = c(0.75, 0.25)
)

print(teste)
```

* Relative abundance of the top 20 ASVs

```{r, fig.width = 20.5, fig.height = 12, echo=FALSE}
#PlotBar
#phylo.relative <- transform_sample_counts(P_Plots, function(otu) otu/sum(otu))
#Subset
top <- names(sort(taxa_sums(metaR_Filter_composi.filt.abs), decreasing=TRUE))[1:20]

sample_data(metaR_Filter_composi.filt.abs)$Transect <- factor(sample_data(metaR_Filter_composi.filt.abs)$Transect, levels = c(1,2,3), labels = c("1","2", "3"))

sample_data(metaR_Filter_composi.filt.abs)$Ecotype <- factor(sample_data(metaR_Filter_composi.filt.abs)$Ecotype, levels = c("Meadow","Alder zone","Spruce-Alder", "Spruce","Pine"), labels = c("Meadow","Alder","Spruce-Alder", "Spruce","Pine"))
#
ps.top <- prune_taxa(top, phylo.relative)
meta <- data.frame(meta(ps.top))
Label <- rownames(meta)
sample_data(ps.top)$Label <- Label
meta <- data.frame(meta(ps.top))
taxonomy <- data.frame(tax_table(ps.top))
otu.relative <- data.frame(otu_table(ps.top))
#
batch1_taxonomy_otu_metadata <- merge(taxonomy, otu.relative, by=0, all=TRUE)
#
batch1_media_melt <- melt(batch1_taxonomy_otu_metadata, id.vars=c("Row.names", "Kingdom","Phylum", "Class", "Order", "Family", "Genus","Species", "taxa_name"))

colnames(batch1_media_melt) <- c("Row.names", "Kingdom","Phylum", "Class", "Order", "Family", "Genus","Species","taxa_name","sample", "RA")
#
Batch1_taxa_all_metadata2 =  merge(batch1_media_melt, meta, by.x = "sample", by.y = "Label")
Batch1_taxa_all_metadata2 = Batch1_taxa_all_metadata2[!Batch1_taxa_all_metadata2$Genus =="Unknown",]
#
list_ <- data.frame(Batch1_taxa_all_metadata2 %>%
                      dplyr::group_by(Genus) %>%
                      dplyr::summarise(RA_count = sum(as.numeric(RA))) %>%
                      dplyr::arrange(desc(RA_count)))
list_sp <- list_$Genus
#
#Batch1_taxa_all_metadata2$Species <- factor(Batch1_taxa_all_metadata2$Species, levels = list_sp)
#Batch1_taxa_all_metadata2$taxa_name <- factor(Batch1_taxa_all_metadata2$taxa_name, levels = list_sp)
#Batch1_taxa_all_metadata2$Phylum <- factor(Batch1_taxa_all_metadata2$Phylum, levels = list_sp)
#Batch1_taxa_all_metadata2$Family <- factor(Batch1_taxa_all_metadata2$Family, levels = list_sp)
Batch1_taxa_all_metadata2$Genus <- factor(Batch1_taxa_all_metadata2$Genus, levels = list_sp)
##Changing the color

ps.top_list <- subset_taxa(ps.top, (Genus!="Unknown") | is.na(Genus))

getPalette = colorRampPalette(brewer.pal(8, "Dark2"))
speciesList = unique(tax_table(ps.top_list)[,"Genus"])
speciesPalette = getPalette(length(speciesList))
names(speciesPalette) = speciesList
#Change for Species, Genus


Batch1_taxa_all_metadata2$R2 <- sapply(Batch1_taxa_all_metadata2$RA, as.numeric)
Batch1_taxa_all_metadata2$Relative_Abundance <- log10(as.numeric(Batch1_taxa_all_metadata2$R2 +1))


RelativeAbundance <-  ggplot(data=Batch1_taxa_all_metadata2, aes(x=Ecotype, group = Genus)) +
  geom_bar(aes(y=Relative_Abundance, fill = Genus),stat="identity") + #colour="#f8edeb" , alpha=.7
  theme_pubr(border = TRUE) +
  theme(axis.text.x = element_text(size = 14, hjust = 0.5), 
        axis.text.y = element_text(size = 14, hjust = 1),
        axis.title.x.bottom = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        legend.position = "bottom") +
  scale_fill_manual(values= speciesPalette) +
  facet_wrap(~Transect, ncol = 1, scales = "free", strip.position="right")

RelativeAbundance
```

# Summary

Help is needed with running the "nfcore/ampliseq" pipeline developed
at NGI for the analyses of fungal ITS1 amplicons, Illumina Miseq
analysis NGI project ID P5953 (M.Hogberg_17_01_project summary from
2018-01-19 by Chuan Wang refers to P9723, >=Q30 (mean(SD), 70(2) (%),
Sum Reads=15 650 000, Mean reads per sample 171 711, 1 pool of
amplicons, 1 flowcell v3, PE 2x301bp (validated method),
demultiplexing, quality control and raw data delivery on Uppmax
(validated method). Agreement number M.Hogberg_16_01-20160826. Grus
delivery project delivery 00654. Because my support application
2019-01-17 was rejected, I have collaborated with partners in US on
this matter but all is extremely delayed for known reasons. I got some
hope today when I read about the recently developed pipeline for
fungal analyses! Unfortunately, I have no programming skills but have
a BSc in Molecular Biology.

Short summary of the work.  

# Further Work  

Further steps to be taken (if needed).

# References

Relevant references for methods, tools etc.

# Deliverables  

Files delivered to the user with descriptions.

## Directory  

```sh
/data/processed/b/

8 directories, 18 files
```

Total size is XX GB.

# Timeline

# Practical Info  
## Data responsibility

The responsibility for data archiving lies with the PI of the project. We do not offer long-term storage or retrieval of data.

+ __NBIS & Uppnex: __ We kindly ask that you remove the files from UPPMAX/UPPNEX. The main storage at UPPNEX is optimized for high-speed and parallel access, which makes it expensive and not the right place for longer time archiving. Please consider others by not taking up the expensive space. Please note that UPPMAX is a resource separate from the Bioinformatics Platform, administered by the Swedish National Infrastructure for Computing (SNIC) and SNIC-specifc project rules apply to all projects hosted at UPPMAX.   
+ __Sensitive data :__ Please note that special considerations may apply to the human-derived legally considered sensitive personal data. These should be handled according to specific laws and regulations as outlined e.g. [here](http://nbis.se/support/human-data.html).  
+ __Long-term backup :__ We recommend asking your local IT for support with long-term data archiving. Also a newly established [Data Office](https://www.scilifelab.se/data/) at SciLifeLab may be of help to discuss other options.  

## Acknowledgments

If you are presenting the results in a paper, at a workshop or conference, we kindly ask you to acknowledge us.

+ __NBIS staff__ are encouraged to be co-authors when this is merited in accordance to the ethical recommendations for authorship, e.g. [ICMJE recommendations](http://www.icmje.org/recommendations/browse/roles-and-responsibilities/defining-the-role-of-authors-and-contributors.html). If applicable, please include __Juliana, Assis Geraldo, National Bioinformatics Infrastructure Sweden, Science for Life Laboratory, NBIS__, as co-author. In other cases, NBIS would be grateful if support by us is acknowledged in publications according to this example:

> "Support by NBIS (National Bioinformatics Infrastructure Sweden) is gratefully acknowledged."

+ __UPPMAX__ kindly asks you to [acknowledge UPPMAX and SNIC](https://www.uppmax.uu.se/support/faq/general-miscellaneous-faq/acknowledging-uppmax--snic--and-uppnex/). If applicable, please add:

> "The computations were performed on resources provided by SNIC through Uppsala Multidisciplinary Center for Advanced Computational Science (UPPMAX) under Project SNIC 2022-22-352."

+ __NGI :__ For publications based on data from NGI Sweden, NGI, SciLifeLab and UPPMAX should be [acknowledged](https://ngisweden.scilifelab.se/info/faq#how-do-i-acknowledge-ngi-in-my-publication) like so:  

> "The authors would like to acknowledge support from Science for Life Laboratory (SciLifeLab), the National Genomics Infrastructure (NGI), and Uppsala Multidisciplinary Center for Advanced Computational Science (UPPMAX) for providing assistance in massive parallel sequencing and computational infrastructure."

# Support Completion  

You should soon be contacted by one of our managers with a request to close down the project in our internal system and for invoicing matters. If we do not hear from you within 30 days the project will be automatically closed and invoice sent. Again, we would like to remind you about data responsibility and acknowledgements, see sections: **Data Responsibility** and **Acknowledgments**.

You are welcome to come back to us with further data analysis request at any time via http://nbis.se/support/support.html.

Thank you for using NBIS.

```{r,eval=FALSE,echo=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("Report_Project6198.Rmd")
# then run this to convert HTML to PDF (if needed)
#pagedown::chrome_print("Report_Project6198.html",output="Report_Project6198.pdf")
```
